package pbgen

//this file is generated by gsync, do not modify it manually !!!

import "gpsync/syncdep"
import "google.golang.org/protobuf/encoding/protowire"
import "math"
import "slices"

type TestSync struct {
	id             int32
	idINDEX        int
	u32            uint32
	u32INDEX       int
	i64            int64
	i64INDEX       int
	u64            uint64
	u64INDEX       int
	b              bool
	bINDEX         int
	e              ColorType
	eINDEX         int
	str            string
	strINDEX       int
	obj            *PersonSync
	objINDEX       int
	i32Arr         *syncdep.ArraySync[int32]
	i32ArrINDEX    int
	u32Arr         *syncdep.ArraySync[uint32]
	u32ArrINDEX    int
	i64Arr         *syncdep.ArraySync[int64]
	i64ArrINDEX    int
	u64Arr         *syncdep.ArraySync[uint64]
	u64ArrINDEX    int
	boolArr        *syncdep.ArraySync[bool]
	boolArrINDEX   int
	enumArr        *syncdep.ArraySync[ColorType]
	enumArrINDEX   int
	strArr         *syncdep.ArraySync[string]
	strArrINDEX    int
	i32Map         *syncdep.MapSync[int32, *TestI32MapSync]
	i32MapINDEX    int
	u32Map         *syncdep.MapSync[uint32, *TestU32MapSync]
	u32MapINDEX    int
	i64Map         *syncdep.MapSync[int64, *TestI64MapSync]
	i64MapINDEX    int
	u64Map         *syncdep.MapSync[uint64, *TestU64MapSync]
	u64MapINDEX    int
	boolMap        *syncdep.MapSync[bool, *TestBoolMapSync]
	boolMapINDEX   int
	strMap         *syncdep.MapSync[string, *TestStringMapSync]
	strMapINDEX    int
	f32            float32
	f32INDEX       int
	f64            float64
	f64INDEX       int
	f32Arr         *syncdep.ArraySync[float32]
	f32ArrINDEX    int
	f64Arr         *syncdep.ArraySync[float64]
	f64ArrINDEX    int
	dirtyFieldMark []uint8
	parent         syncdep.Sync
	indexInParent  int
}

func NewTestSync() *TestSync {
	return &TestSync{
		idINDEX:        0,
		u32INDEX:       1,
		i64INDEX:       2,
		u64INDEX:       3,
		bINDEX:         4,
		eINDEX:         5,
		strINDEX:       6,
		objINDEX:       7,
		i32ArrINDEX:    8,
		u32ArrINDEX:    9,
		i64ArrINDEX:    10,
		u64ArrINDEX:    11,
		boolArrINDEX:   12,
		enumArrINDEX:   13,
		strArrINDEX:    14,
		i32MapINDEX:    15,
		u32MapINDEX:    16,
		i64MapINDEX:    17,
		u64MapINDEX:    18,
		boolMapINDEX:   19,
		strMapINDEX:    20,
		f32INDEX:       21,
		f64INDEX:       22,
		f32ArrINDEX:    23,
		f64ArrINDEX:    24,
		dirtyFieldMark: make([]uint8, 4),
	}
}
func (x *TestSync) Clear() *TestSync {
	x.SetId(0)
	x.SetU32(0)
	x.SetI64(0)
	x.SetU64(0)
	x.SetB(false)
	x.SetE(ColorType_Red)
	x.SetStr("")
	if x.obj != nil {
		x.obj.Clear()
	}
	if x.i32Arr != nil {
		x.i32Arr.Clear()
	}
	if x.u32Arr != nil {
		x.u32Arr.Clear()
	}
	if x.i64Arr != nil {
		x.i64Arr.Clear()
	}
	if x.u64Arr != nil {
		x.u64Arr.Clear()
	}
	if x.boolArr != nil {
		x.boolArr.Clear()
	}
	if x.enumArr != nil {
		x.enumArr.Clear()
	}
	if x.strArr != nil {
		x.strArr.Clear()
	}
	if x.i32Map != nil {
		x.i32Map.Clear()
	}
	if x.u32Map != nil {
		x.u32Map.Clear()
	}
	if x.i64Map != nil {
		x.i64Map.Clear()
	}
	if x.u64Map != nil {
		x.u64Map.Clear()
	}
	if x.boolMap != nil {
		x.boolMap.Clear()
	}
	if x.strMap != nil {
		x.strMap.Clear()
	}
	x.SetF32(0)
	x.SetF64(0)
	if x.f32Arr != nil {
		x.f32Arr.Clear()
	}
	if x.f64Arr != nil {
		x.f64Arr.Clear()
	}
	return x
}
func (x *TestSync) CopyToPb(r *Test) *TestSync {
	r.SetId(x.id)
	r.SetU32(x.u32)
	r.SetI64(x.i64)
	r.SetU64(x.u64)
	r.SetB(x.b)
	r.SetE(x.e)
	r.SetStr(x.str)
	if x.obj != nil {
		tmp := &Person{}
		x.obj.CopyToPb(tmp)
		r.SetObj(tmp)
	}
	if x.i32Arr != nil && x.i32Arr.Len() > 0 {
		r.SetI32Arr(x.i32Arr.ValueView())
	}
	if x.u32Arr != nil && x.u32Arr.Len() > 0 {
		r.SetU32Arr(x.u32Arr.ValueView())
	}
	if x.i64Arr != nil && x.i64Arr.Len() > 0 {
		r.SetI64Arr(x.i64Arr.ValueView())
	}
	if x.u64Arr != nil && x.u64Arr.Len() > 0 {
		r.SetU64Arr(x.u64Arr.ValueView())
	}
	if x.boolArr != nil && x.boolArr.Len() > 0 {
		r.SetBoolArr(x.boolArr.ValueView())
	}
	if x.enumArr != nil && x.enumArr.Len() > 0 {
		r.SetEnumArr(x.enumArr.ValueView())
	}
	if x.strArr != nil && x.strArr.Len() > 0 {
		r.SetStrArr(x.strArr.ValueView())
	}
	if x.i32Map != nil && x.i32Map.Len() > 0 {
		tmp := make(map[int32]*TestI32Map)
		x.i32Map.Each(func(k int32, v *TestI32MapSync) bool {
			tmpV := &TestI32Map{}
			v.CopyToPb(tmpV)
			tmp[k] = tmpV
			return true
		})
		r.SetI32Map(tmp)
	}
	if x.u32Map != nil && x.u32Map.Len() > 0 {
		tmp := make(map[uint32]*TestU32Map)
		x.u32Map.Each(func(k uint32, v *TestU32MapSync) bool {
			tmpV := &TestU32Map{}
			v.CopyToPb(tmpV)
			tmp[k] = tmpV
			return true
		})
		r.SetU32Map(tmp)
	}
	if x.i64Map != nil && x.i64Map.Len() > 0 {
		tmp := make(map[int64]*TestI64Map)
		x.i64Map.Each(func(k int64, v *TestI64MapSync) bool {
			tmpV := &TestI64Map{}
			v.CopyToPb(tmpV)
			tmp[k] = tmpV
			return true
		})
		r.SetI64Map(tmp)
	}
	if x.u64Map != nil && x.u64Map.Len() > 0 {
		tmp := make(map[uint64]*TestU64Map)
		x.u64Map.Each(func(k uint64, v *TestU64MapSync) bool {
			tmpV := &TestU64Map{}
			v.CopyToPb(tmpV)
			tmp[k] = tmpV
			return true
		})
		r.SetU64Map(tmp)
	}
	if x.boolMap != nil && x.boolMap.Len() > 0 {
		tmp := make(map[bool]*TestBoolMap)
		x.boolMap.Each(func(k bool, v *TestBoolMapSync) bool {
			tmpV := &TestBoolMap{}
			v.CopyToPb(tmpV)
			tmp[k] = tmpV
			return true
		})
		r.SetBoolMap(tmp)
	}
	if x.strMap != nil && x.strMap.Len() > 0 {
		tmp := make(map[string]*TestStringMap)
		x.strMap.Each(func(k string, v *TestStringMapSync) bool {
			tmpV := &TestStringMap{}
			v.CopyToPb(tmpV)
			tmp[k] = tmpV
			return true
		})
		r.SetStrMap(tmp)
	}
	r.SetF32(x.f32)
	r.SetF64(x.f64)
	if x.f32Arr != nil && x.f32Arr.Len() > 0 {
		r.SetF32Arr(x.f32Arr.ValueView())
	}
	if x.f64Arr != nil && x.f64Arr.Len() > 0 {
		r.SetF64Arr(x.f64Arr.ValueView())
	}
	return x
}
func (x *TestSync) CopyFromPb(r *Test) *TestSync {
	if r.Id != nil {
		x.SetId(*r.Id)
	}
	if r.U32 != nil {
		x.SetU32(*r.U32)
	}
	if r.I64 != nil {
		x.SetI64(*r.I64)
	}
	if r.U64 != nil {
		x.SetU64(*r.U64)
	}
	if r.B != nil {
		x.SetB(*r.B)
	}
	if r.E != nil {
		x.SetE(*r.E)
	}
	if r.Str != nil {
		x.SetStr(*r.Str)
	}
	if r.Obj != nil {
		x.GetObj().CopyFromPb(r.Obj)
	}
	if r.I32Arr != nil {
		x.GetI32Arr().AddAll(r.I32Arr)
	}
	if r.U32Arr != nil {
		x.GetU32Arr().AddAll(r.U32Arr)
	}
	if r.I64Arr != nil {
		x.GetI64Arr().AddAll(r.I64Arr)
	}
	if r.U64Arr != nil {
		x.GetU64Arr().AddAll(r.U64Arr)
	}
	if r.BoolArr != nil {
		x.GetBoolArr().AddAll(r.BoolArr)
	}
	if r.EnumArr != nil {
		x.GetEnumArr().AddAll(r.EnumArr)
	}
	if r.StrArr != nil {
		x.GetStrArr().AddAll(r.StrArr)
	}
	for k, v := range r.I32Map {
		if v != nil {
			vv := NewTestI32MapSync()
			vv.CopyFromPb(v)
			x.GetI32Map().Put(k, vv)
		}
	}
	for k, v := range r.U32Map {
		if v != nil {
			vv := NewTestU32MapSync()
			vv.CopyFromPb(v)
			x.GetU32Map().Put(k, vv)
		}
	}
	for k, v := range r.I64Map {
		if v != nil {
			vv := NewTestI64MapSync()
			vv.CopyFromPb(v)
			x.GetI64Map().Put(k, vv)
		}
	}
	for k, v := range r.U64Map {
		if v != nil {
			vv := NewTestU64MapSync()
			vv.CopyFromPb(v)
			x.GetU64Map().Put(k, vv)
		}
	}
	for k, v := range r.BoolMap {
		if v != nil {
			vv := NewTestBoolMapSync()
			vv.CopyFromPb(v)
			x.GetBoolMap().Put(k, vv)
		}
	}
	for k, v := range r.StrMap {
		if v != nil {
			vv := NewTestStringMapSync()
			vv.CopyFromPb(v)
			x.GetStrMap().Put(k, vv)
		}
	}
	if r.F32 != nil {
		x.SetF32(*r.F32)
	}
	if r.F64 != nil {
		x.SetF64(*r.F64)
	}
	if r.F32Arr != nil {
		x.GetF32Arr().AddAll(r.F32Arr)
	}
	if r.F64Arr != nil {
		x.GetF64Arr().AddAll(r.F64Arr)
	}
	return x
}
func (x *TestSync) MergeDirtyFromPb(r *Test) {
	if r.Id != nil {
		x.SetId(*r.Id)
	}
	if r.U32 != nil {
		x.SetU32(*r.U32)
	}
	if r.I64 != nil {
		x.SetI64(*r.I64)
	}
	if r.U64 != nil {
		x.SetU64(*r.U64)
	}
	if r.B != nil {
		x.SetB(*r.B)
	}
	if r.E != nil {
		x.SetE(*r.E)
	}
	if r.Str != nil {
		x.SetStr(*r.Str)
	}
	if r.Obj != nil {
		x.GetObj().MergeDirtyFromPb(r.Obj)
	}
	if len(r.I32Arr) > 0 || r.I32ArrCleared {
		x.GetI32Arr().Clear()
		x.i32Arr.AddAll(r.I32Arr)
	}
	if len(r.U32Arr) > 0 || r.U32ArrCleared {
		x.GetU32Arr().Clear()
		x.u32Arr.AddAll(r.U32Arr)
	}
	if len(r.I64Arr) > 0 || r.I64ArrCleared {
		x.GetI64Arr().Clear()
		x.i64Arr.AddAll(r.I64Arr)
	}
	if len(r.U64Arr) > 0 || r.U64ArrCleared {
		x.GetU64Arr().Clear()
		x.u64Arr.AddAll(r.U64Arr)
	}
	if len(r.BoolArr) > 0 || r.BoolArrCleared {
		x.GetBoolArr().Clear()
		x.boolArr.AddAll(r.BoolArr)
	}
	if len(r.EnumArr) > 0 || r.EnumArrCleared {
		x.GetEnumArr().Clear()
		x.enumArr.AddAll(r.EnumArr)
	}
	if len(r.StrArr) > 0 || r.StrArrCleared {
		x.GetStrArr().Clear()
		x.strArr.AddAll(r.StrArr)
	}
	if x.i32Map != nil {
		x.GetI32Map().RemoveAll(r.I32MapDeleted)
	}
	for k, v := range r.I32Map {
		var tmp = x.GetI32Map().Get(k)
		if tmp == nil {
			tmp = NewTestI32MapSync()
			tmp.MergeDirtyFromPb(v)
			x.GetI32Map().Put(k, tmp)
		} else {
			tmp.MergeDirtyFromPb(v)
		}
	}
	if x.u32Map != nil {
		x.GetU32Map().RemoveAll(r.U32MapDeleted)
	}
	for k, v := range r.U32Map {
		var tmp = x.GetU32Map().Get(k)
		if tmp == nil {
			tmp = NewTestU32MapSync()
			tmp.MergeDirtyFromPb(v)
			x.GetU32Map().Put(k, tmp)
		} else {
			tmp.MergeDirtyFromPb(v)
		}
	}
	if x.i64Map != nil {
		x.GetI64Map().RemoveAll(r.I64MapDeleted)
	}
	for k, v := range r.I64Map {
		var tmp = x.GetI64Map().Get(k)
		if tmp == nil {
			tmp = NewTestI64MapSync()
			tmp.MergeDirtyFromPb(v)
			x.GetI64Map().Put(k, tmp)
		} else {
			tmp.MergeDirtyFromPb(v)
		}
	}
	if x.u64Map != nil {
		x.GetU64Map().RemoveAll(r.U64MapDeleted)
	}
	for k, v := range r.U64Map {
		var tmp = x.GetU64Map().Get(k)
		if tmp == nil {
			tmp = NewTestU64MapSync()
			tmp.MergeDirtyFromPb(v)
			x.GetU64Map().Put(k, tmp)
		} else {
			tmp.MergeDirtyFromPb(v)
		}
	}
	if x.boolMap != nil {
		x.GetBoolMap().RemoveAll(r.BoolMapDeleted)
	}
	for k, v := range r.BoolMap {
		var tmp = x.GetBoolMap().Get(k)
		if tmp == nil {
			tmp = NewTestBoolMapSync()
			tmp.MergeDirtyFromPb(v)
			x.GetBoolMap().Put(k, tmp)
		} else {
			tmp.MergeDirtyFromPb(v)
		}
	}
	if x.strMap != nil {
		x.GetStrMap().RemoveAll(r.StrMapDeleted)
	}
	for k, v := range r.StrMap {
		var tmp = x.GetStrMap().Get(k)
		if tmp == nil {
			tmp = NewTestStringMapSync()
			tmp.MergeDirtyFromPb(v)
			x.GetStrMap().Put(k, tmp)
		} else {
			tmp.MergeDirtyFromPb(v)
		}
	}
	if r.F32 != nil {
		x.SetF32(*r.F32)
	}
	if r.F64 != nil {
		x.SetF64(*r.F64)
	}
	if len(r.F32Arr) > 0 || r.F32ArrCleared {
		x.GetF32Arr().Clear()
		x.f32Arr.AddAll(r.F32Arr)
	}
	if len(r.F64Arr) > 0 || r.F64ArrCleared {
		x.GetF64Arr().Clear()
		x.f64Arr.AddAll(r.F64Arr)
	}
}
func (x *TestSync) MergeDirtyFromBytes(buf []byte) *TestSync {
	fds := syncdep.PreParseProtoBytes(buf)
	for _, rawF := range fds.Values {
		switch rawF.Number {
		case 2008:
			if rawF.Value.(uint64) > 0 {
				x.i32Arr.Clear()
			}
		case 2009:
			if rawF.Value.(uint64) > 0 {
				x.u32Arr.Clear()
			}
		case 2010:
			if rawF.Value.(uint64) > 0 {
				x.i64Arr.Clear()
			}
		case 2011:
			if rawF.Value.(uint64) > 0 {
				x.u64Arr.Clear()
			}
		case 2012:
			if rawF.Value.(uint64) > 0 {
				x.boolArr.Clear()
			}
		case 2013:
			if rawF.Value.(uint64) > 0 {
				x.enumArr.Clear()
			}
		case 2014:
			if rawF.Value.(uint64) > 0 {
				x.strArr.Clear()
			}
		case 1015:
			if x.i32Map != nil {
				x.i32Map.RemoveAll(syncdep.MustParseVarintArr[int32](&rawF))
			}
		case 1016:
			if x.u32Map != nil {
				x.u32Map.RemoveAll(syncdep.MustParseVarintArr[uint32](&rawF))
			}
		case 1017:
			if x.i64Map != nil {
				x.i64Map.RemoveAll(syncdep.MustParseVarintArr[int64](&rawF))
			}
		case 1018:
			if x.u64Map != nil {
				x.u64Map.RemoveAll(syncdep.MustParseVarintArr[uint64](&rawF))
			}
		case 1019:
			if x.boolMap != nil {
				x.boolMap.RemoveAll(syncdep.MustParseVarintArr[bool](&rawF))
			}
		case 1021:
			if x.strMap != nil {
				x.strMap.Remove(syncdep.Bys2Str(rawF.Value.([]byte)))
			}
		case 2025:
			if rawF.Value.(uint64) > 0 {
				x.f32Arr.Clear()
			}
		case 2026:
			if rawF.Value.(uint64) > 0 {
				x.f64Arr.Clear()
			}
		}
	}
	for _, rawF := range fds.Values {
		switch rawF.Number {
		case 1:
			x.SetId(int32(rawF.Value.(uint64)))
		case 2:
			x.SetU32(uint32(rawF.Value.(uint64)))
		case 3:
			x.SetI64(int64(rawF.Value.(uint64)))
		case 4:
			x.SetU64(uint64(rawF.Value.(uint64)))
		case 5:
			x.SetB(rawF.Value.(uint64) > 0)
		case 6:
			x.SetE(ColorType(rawF.Value.(uint64)))
		case 7:
			x.SetStr(syncdep.Bys2Str(rawF.Value.([]byte)))
		case 22:
			x.GetObj().MergeDirtyFromBytes(rawF.Value.([]byte))
		case 8:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeVarint(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetI32Arr().Add(int32(val))
			}
		case 9:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeVarint(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetU32Arr().Add(uint32(val))
			}
		case 10:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeVarint(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetI64Arr().Add(int64(val))
			}
		case 11:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeVarint(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetU64Arr().Add(uint64(val))
			}
		case 12:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeVarint(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetBoolArr().Add(val > 0)
			}
		case 13:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeVarint(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetEnumArr().Add(ColorType(val))
			}
		case 14:
			x.GetStrArr().Add(syncdep.Bys2Str(rawF.Value.([]byte)))
		case 15:
			mapKV := syncdep.PreParseProtoBytes(rawF.Value.([]byte)).Values
			k := syncdep.GetMapKey[int32](&mapKV[0])
			var tmp = x.GetI32Map().Get(k)
			if tmp == nil {
				tmp = NewTestI32MapSync()
			}
			tmp.MergeDirtyFromBytes(mapKV[1].Value.([]byte))
			x.GetI32Map().Put(k, tmp)
		case 16:
			mapKV := syncdep.PreParseProtoBytes(rawF.Value.([]byte)).Values
			k := syncdep.GetMapKey[uint32](&mapKV[0])
			var tmp = x.GetU32Map().Get(k)
			if tmp == nil {
				tmp = NewTestU32MapSync()
			}
			tmp.MergeDirtyFromBytes(mapKV[1].Value.([]byte))
			x.GetU32Map().Put(k, tmp)
		case 17:
			mapKV := syncdep.PreParseProtoBytes(rawF.Value.([]byte)).Values
			k := syncdep.GetMapKey[int64](&mapKV[0])
			var tmp = x.GetI64Map().Get(k)
			if tmp == nil {
				tmp = NewTestI64MapSync()
			}
			tmp.MergeDirtyFromBytes(mapKV[1].Value.([]byte))
			x.GetI64Map().Put(k, tmp)
		case 18:
			mapKV := syncdep.PreParseProtoBytes(rawF.Value.([]byte)).Values
			k := syncdep.GetMapKey[uint64](&mapKV[0])
			var tmp = x.GetU64Map().Get(k)
			if tmp == nil {
				tmp = NewTestU64MapSync()
			}
			tmp.MergeDirtyFromBytes(mapKV[1].Value.([]byte))
			x.GetU64Map().Put(k, tmp)
		case 19:
			mapKV := syncdep.PreParseProtoBytes(rawF.Value.([]byte)).Values
			k := syncdep.GetMapKey[bool](&mapKV[0])
			var tmp = x.GetBoolMap().Get(k)
			if tmp == nil {
				tmp = NewTestBoolMapSync()
			}
			tmp.MergeDirtyFromBytes(mapKV[1].Value.([]byte))
			x.GetBoolMap().Put(k, tmp)
		case 21:
			mapKV := syncdep.PreParseProtoBytes(rawF.Value.([]byte)).Values
			k := syncdep.GetMapKey[string](&mapKV[0])
			var tmp = x.GetStrMap().Get(k)
			if tmp == nil {
				tmp = NewTestStringMapSync()
			}
			tmp.MergeDirtyFromBytes(mapKV[1].Value.([]byte))
			x.GetStrMap().Put(k, tmp)
		case 23:
			x.SetF32(rawF.Value.(float32))
		case 24:
			x.SetF64(rawF.Value.(float64))
		case 25:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeFixed32(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetF32Arr().Add(math.Float32frombits(val))
			}
		case 26:
			tmp := rawF.Value.([]byte)
			for len(tmp) > 0 {
				val, n := protowire.ConsumeFixed64(tmp)
				if n < 0 {
					panic(n)
				}
				tmp = tmp[n:]
				x.GetF64Arr().Add(math.Float64frombits(val))
			}
		}
	}
	return x
}
func (x *TestSync) MergeDirtyToBytes() []byte {
	var buf []byte
	if x.isIdDirty() {
		buf = protowire.AppendTag(buf, 1, 0)
		buf = syncdep.AppendFieldValue(buf, x.id)
	}
	if x.isU32Dirty() {
		buf = protowire.AppendTag(buf, 2, 0)
		buf = syncdep.AppendFieldValue(buf, x.u32)
	}
	if x.isI64Dirty() {
		buf = protowire.AppendTag(buf, 3, 0)
		buf = syncdep.AppendFieldValue(buf, x.i64)
	}
	if x.isU64Dirty() {
		buf = protowire.AppendTag(buf, 4, 0)
		buf = syncdep.AppendFieldValue(buf, x.u64)
	}
	if x.isBDirty() {
		buf = protowire.AppendTag(buf, 5, 0)
		buf = syncdep.AppendFieldValue(buf, x.b)
	}
	if x.isEDirty() {
		buf = protowire.AppendTag(buf, 6, 0)
		buf = syncdep.AppendFieldValue(buf, int32(x.e))
	}
	if x.isStrDirty() {
		buf = protowire.AppendTag(buf, 7, 2)
		buf = syncdep.AppendFieldValue(buf, x.str)
	}
	if x.isObjDirty() {
		if x.obj != nil {
			bytes := x.obj.MergeDirtyToBytes()
			buf = protowire.AppendTag(buf, 22, 2)
			buf = syncdep.AppendFieldValue(buf, bytes)
		}
	}
	if x.isI32ArrDirty() {
		if x.i32Arr != nil && x.i32Arr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2008, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.i32Arr.Each(func(i int, v int32) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 8, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2008, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isU32ArrDirty() {
		if x.u32Arr != nil && x.u32Arr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2009, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.u32Arr.Each(func(i int, v uint32) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 9, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2009, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isI64ArrDirty() {
		if x.i64Arr != nil && x.i64Arr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2010, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.i64Arr.Each(func(i int, v int64) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 10, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2010, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isU64ArrDirty() {
		if x.u64Arr != nil && x.u64Arr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2011, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.u64Arr.Each(func(i int, v uint64) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 11, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2011, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isBoolArrDirty() {
		if x.boolArr != nil && x.boolArr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2012, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.boolArr.Each(func(i int, v bool) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 12, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2012, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isEnumArrDirty() {
		if x.enumArr != nil && x.enumArr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2013, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.enumArr.Each(func(i int, v ColorType) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, int32(v))
				return true
			})
			buf = protowire.AppendTag(buf, 13, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2013, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isStrArrDirty() {
		if x.strArr != nil && x.strArr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2014, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			x.strArr.Each(func(i int, v string) bool {
				buf = protowire.AppendTag(buf, 14, 2)
				buf = protowire.AppendString(buf, v)
				return true
			})
		} else {
			buf = protowire.AppendTag(buf, 2014, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isI32MapDirty() {
		if len(x.i32Map.Deleted()) > 0 {
			deleted := x.i32Map.Deleted()
			var packedBuf []byte
			for v := range deleted {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
			}
			buf = protowire.AppendTag(buf, 15, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		}
		if x.i32Map.Len() > 0 {
			x.i32Map.Each(func(k int32, v *TestI32MapSync) bool {
				if !x.i32Map.ContainDirtied(k) {
					return true
				}
				buf = syncdep.AppendMapFieldKeyValue(buf, 15, k, v.MergeDirtyToBytes())
				return true
			})
		}
	}
	if x.isU32MapDirty() {
		if len(x.u32Map.Deleted()) > 0 {
			deleted := x.u32Map.Deleted()
			var packedBuf []byte
			for v := range deleted {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
			}
			buf = protowire.AppendTag(buf, 16, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		}
		if x.u32Map.Len() > 0 {
			x.u32Map.Each(func(k uint32, v *TestU32MapSync) bool {
				if !x.u32Map.ContainDirtied(k) {
					return true
				}
				buf = syncdep.AppendMapFieldKeyValue(buf, 16, k, v.MergeDirtyToBytes())
				return true
			})
		}
	}
	if x.isI64MapDirty() {
		if len(x.i64Map.Deleted()) > 0 {
			deleted := x.i64Map.Deleted()
			var packedBuf []byte
			for v := range deleted {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
			}
			buf = protowire.AppendTag(buf, 17, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		}
		if x.i64Map.Len() > 0 {
			x.i64Map.Each(func(k int64, v *TestI64MapSync) bool {
				if !x.i64Map.ContainDirtied(k) {
					return true
				}
				buf = syncdep.AppendMapFieldKeyValue(buf, 17, k, v.MergeDirtyToBytes())
				return true
			})
		}
	}
	if x.isU64MapDirty() {
		if len(x.u64Map.Deleted()) > 0 {
			deleted := x.u64Map.Deleted()
			var packedBuf []byte
			for v := range deleted {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
			}
			buf = protowire.AppendTag(buf, 18, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		}
		if x.u64Map.Len() > 0 {
			x.u64Map.Each(func(k uint64, v *TestU64MapSync) bool {
				if !x.u64Map.ContainDirtied(k) {
					return true
				}
				buf = syncdep.AppendMapFieldKeyValue(buf, 18, k, v.MergeDirtyToBytes())
				return true
			})
		}
	}
	if x.isBoolMapDirty() {
		if len(x.boolMap.Deleted()) > 0 {
			deleted := x.boolMap.Deleted()
			var packedBuf []byte
			for v := range deleted {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
			}
			buf = protowire.AppendTag(buf, 19, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		}
		if x.boolMap.Len() > 0 {
			x.boolMap.Each(func(k bool, v *TestBoolMapSync) bool {
				if !x.boolMap.ContainDirtied(k) {
					return true
				}
				buf = syncdep.AppendMapFieldKeyValue(buf, 19, k, v.MergeDirtyToBytes())
				return true
			})
		}
	}
	if x.isStrMapDirty() {
		if len(x.strMap.Deleted()) > 0 {
			deleted := x.strMap.Deleted()
			for del := range deleted {
				buf = protowire.AppendTag(buf, 1021, protowire.BytesType)
				buf = protowire.AppendString(buf, del)
			}
		}
		if x.strMap.Len() > 0 {
			x.strMap.Each(func(k string, v *TestStringMapSync) bool {
				if !x.strMap.ContainDirtied(k) {
					return true
				}
				buf = syncdep.AppendMapFieldKeyValue(buf, 21, k, v.MergeDirtyToBytes())
				return true
			})
		}
	}
	if x.isF32Dirty() {
		buf = protowire.AppendTag(buf, 23, 5)
		buf = syncdep.AppendFieldValue(buf, x.f32)
	}
	if x.isF64Dirty() {
		buf = protowire.AppendTag(buf, 24, 1)
		buf = syncdep.AppendFieldValue(buf, x.f64)
	}
	if x.isF32ArrDirty() {
		if x.f32Arr != nil && x.f32Arr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2025, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.f32Arr.Each(func(i int, v float32) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 25, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2025, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	if x.isF64ArrDirty() {
		if x.f64Arr != nil && x.f64Arr.Len() > 0 {
			buf = protowire.AppendTag(buf, 2026, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, false)
			var packedBuf []byte
			x.f64Arr.Each(func(i int, v float64) bool {
				packedBuf = syncdep.AppendFieldValue(packedBuf, v)
				return true
			})
			buf = protowire.AppendTag(buf, 26, 2)
			buf = protowire.AppendBytes(buf, packedBuf)
		} else {
			buf = protowire.AppendTag(buf, 2026, protowire.VarintType)
			buf = syncdep.AppendFieldValue(buf, true)
		}
	}
	return buf
}
func (x *TestSync) MergeDirtyToPb(r *Test) {
	if x.isIdDirty() {
		r.SetId(x.id)
	}
	if x.isU32Dirty() {
		r.SetU32(x.u32)
	}
	if x.isI64Dirty() {
		r.SetI64(x.i64)
	}
	if x.isU64Dirty() {
		r.SetU64(x.u64)
	}
	if x.isBDirty() {
		r.SetB(x.b)
	}
	if x.isEDirty() {
		r.SetE(x.e)
	}
	if x.isStrDirty() {
		r.SetStr(x.str)
	}
	if x.isObjDirty() {
		if r.Obj == nil {
			r.Obj = &Person{}
		}
		x.obj.MergeDirtyToPb(r.Obj)
	}
	if x.isI32ArrDirty() {
		count := x.i32Arr.Len()
		r.I32Arr = make([]int32, 0)
		if count > 0 {
			r.I32ArrCleared = false
			r.I32Arr = append(r.I32Arr, x.i32Arr.ValueView()...)
		} else {
			r.I32ArrCleared = true
		}
	}
	if x.isU32ArrDirty() {
		count := x.u32Arr.Len()
		r.U32Arr = make([]uint32, 0)
		if count > 0 {
			r.U32ArrCleared = false
			r.U32Arr = append(r.U32Arr, x.u32Arr.ValueView()...)
		} else {
			r.U32ArrCleared = true
		}
	}
	if x.isI64ArrDirty() {
		count := x.i64Arr.Len()
		r.I64Arr = make([]int64, 0)
		if count > 0 {
			r.I64ArrCleared = false
			r.I64Arr = append(r.I64Arr, x.i64Arr.ValueView()...)
		} else {
			r.I64ArrCleared = true
		}
	}
	if x.isU64ArrDirty() {
		count := x.u64Arr.Len()
		r.U64Arr = make([]uint64, 0)
		if count > 0 {
			r.U64ArrCleared = false
			r.U64Arr = append(r.U64Arr, x.u64Arr.ValueView()...)
		} else {
			r.U64ArrCleared = true
		}
	}
	if x.isBoolArrDirty() {
		count := x.boolArr.Len()
		r.BoolArr = make([]bool, 0)
		if count > 0 {
			r.BoolArrCleared = false
			r.BoolArr = append(r.BoolArr, x.boolArr.ValueView()...)
		} else {
			r.BoolArrCleared = true
		}
	}
	if x.isEnumArrDirty() {
		count := x.enumArr.Len()
		r.EnumArr = make([]ColorType, 0)
		if count > 0 {
			r.EnumArrCleared = false
			r.EnumArr = append(r.EnumArr, x.enumArr.ValueView()...)
		} else {
			r.EnumArrCleared = true
		}
	}
	if x.isStrArrDirty() {
		count := x.strArr.Len()
		r.StrArr = make([]string, 0)
		if count > 0 {
			r.StrArrCleared = false
			r.StrArr = append(r.StrArr, x.strArr.ValueView()...)
		} else {
			r.StrArrCleared = true
		}
	}
	if x.isI32MapDirty() {
		updated := make([]int32, 0)
		if r.I32Map != nil {
			for k := range r.I32Map {
				if x.i32Map.ContainDeleted(k) {
					delete(r.I32Map, k)
				}
				if x.i32Map.ContainDirtied(k) {
					updated = append(updated, k)
					tmp := x.i32Map.Get(k)
					if r.I32Map[k] == nil {
						r.I32Map[k] = &TestI32Map{}
					}
					tmp.MergeDirtyToPb(r.I32Map[k])
				}
			}
		} else {
			r.I32Map = make(map[int32]*TestI32Map)
		}
		for k := range x.i32Map.Dirtied() {
			if !slices.Contains(updated, k) {
				tmp := x.i32Map.Get(k)
				if r.I32Map[k] == nil {
					r.I32Map[k] = &TestI32Map{}
				}
				tmp.MergeDirtyToPb(r.I32Map[k])
			}
		}
		if r.I32MapDeleted == nil && len(x.i32Map.Deleted()) > 0 {
			r.I32MapDeleted = make([]int32, 0)
		}
		for k := range x.i32Map.Deleted() {
			if !slices.Contains(r.I32MapDeleted, k) {
				r.I32MapDeleted = append(r.I32MapDeleted, k)
			}
		}
	}
	if x.isU32MapDirty() {
		updated := make([]uint32, 0)
		if r.U32Map != nil {
			for k := range r.U32Map {
				if x.u32Map.ContainDeleted(k) {
					delete(r.U32Map, k)
				}
				if x.u32Map.ContainDirtied(k) {
					updated = append(updated, k)
					tmp := x.u32Map.Get(k)
					if r.U32Map[k] == nil {
						r.U32Map[k] = &TestU32Map{}
					}
					tmp.MergeDirtyToPb(r.U32Map[k])
				}
			}
		} else {
			r.U32Map = make(map[uint32]*TestU32Map)
		}
		for k := range x.u32Map.Dirtied() {
			if !slices.Contains(updated, k) {
				tmp := x.u32Map.Get(k)
				if r.U32Map[k] == nil {
					r.U32Map[k] = &TestU32Map{}
				}
				tmp.MergeDirtyToPb(r.U32Map[k])
			}
		}
		if r.U32MapDeleted == nil && len(x.u32Map.Deleted()) > 0 {
			r.U32MapDeleted = make([]uint32, 0)
		}
		for k := range x.u32Map.Deleted() {
			if !slices.Contains(r.U32MapDeleted, k) {
				r.U32MapDeleted = append(r.U32MapDeleted, k)
			}
		}
	}
	if x.isI64MapDirty() {
		updated := make([]int64, 0)
		if r.I64Map != nil {
			for k := range r.I64Map {
				if x.i64Map.ContainDeleted(k) {
					delete(r.I64Map, k)
				}
				if x.i64Map.ContainDirtied(k) {
					updated = append(updated, k)
					tmp := x.i64Map.Get(k)
					if r.I64Map[k] == nil {
						r.I64Map[k] = &TestI64Map{}
					}
					tmp.MergeDirtyToPb(r.I64Map[k])
				}
			}
		} else {
			r.I64Map = make(map[int64]*TestI64Map)
		}
		for k := range x.i64Map.Dirtied() {
			if !slices.Contains(updated, k) {
				tmp := x.i64Map.Get(k)
				if r.I64Map[k] == nil {
					r.I64Map[k] = &TestI64Map{}
				}
				tmp.MergeDirtyToPb(r.I64Map[k])
			}
		}
		if r.I64MapDeleted == nil && len(x.i64Map.Deleted()) > 0 {
			r.I64MapDeleted = make([]int64, 0)
		}
		for k := range x.i64Map.Deleted() {
			if !slices.Contains(r.I64MapDeleted, k) {
				r.I64MapDeleted = append(r.I64MapDeleted, k)
			}
		}
	}
	if x.isU64MapDirty() {
		updated := make([]uint64, 0)
		if r.U64Map != nil {
			for k := range r.U64Map {
				if x.u64Map.ContainDeleted(k) {
					delete(r.U64Map, k)
				}
				if x.u64Map.ContainDirtied(k) {
					updated = append(updated, k)
					tmp := x.u64Map.Get(k)
					if r.U64Map[k] == nil {
						r.U64Map[k] = &TestU64Map{}
					}
					tmp.MergeDirtyToPb(r.U64Map[k])
				}
			}
		} else {
			r.U64Map = make(map[uint64]*TestU64Map)
		}
		for k := range x.u64Map.Dirtied() {
			if !slices.Contains(updated, k) {
				tmp := x.u64Map.Get(k)
				if r.U64Map[k] == nil {
					r.U64Map[k] = &TestU64Map{}
				}
				tmp.MergeDirtyToPb(r.U64Map[k])
			}
		}
		if r.U64MapDeleted == nil && len(x.u64Map.Deleted()) > 0 {
			r.U64MapDeleted = make([]uint64, 0)
		}
		for k := range x.u64Map.Deleted() {
			if !slices.Contains(r.U64MapDeleted, k) {
				r.U64MapDeleted = append(r.U64MapDeleted, k)
			}
		}
	}
	if x.isBoolMapDirty() {
		updated := make([]bool, 0)
		if r.BoolMap != nil {
			for k := range r.BoolMap {
				if x.boolMap.ContainDeleted(k) {
					delete(r.BoolMap, k)
				}
				if x.boolMap.ContainDirtied(k) {
					updated = append(updated, k)
					tmp := x.boolMap.Get(k)
					if r.BoolMap[k] == nil {
						r.BoolMap[k] = &TestBoolMap{}
					}
					tmp.MergeDirtyToPb(r.BoolMap[k])
				}
			}
		} else {
			r.BoolMap = make(map[bool]*TestBoolMap)
		}
		for k := range x.boolMap.Dirtied() {
			if !slices.Contains(updated, k) {
				tmp := x.boolMap.Get(k)
				if r.BoolMap[k] == nil {
					r.BoolMap[k] = &TestBoolMap{}
				}
				tmp.MergeDirtyToPb(r.BoolMap[k])
			}
		}
		if r.BoolMapDeleted == nil && len(x.boolMap.Deleted()) > 0 {
			r.BoolMapDeleted = make([]bool, 0)
		}
		for k := range x.boolMap.Deleted() {
			if !slices.Contains(r.BoolMapDeleted, k) {
				r.BoolMapDeleted = append(r.BoolMapDeleted, k)
			}
		}
	}
	if x.isStrMapDirty() {
		updated := make([]string, 0)
		if r.StrMap != nil {
			for k := range r.StrMap {
				if x.strMap.ContainDeleted(k) {
					delete(r.StrMap, k)
				}
				if x.strMap.ContainDirtied(k) {
					updated = append(updated, k)
					tmp := x.strMap.Get(k)
					if r.StrMap[k] == nil {
						r.StrMap[k] = &TestStringMap{}
					}
					tmp.MergeDirtyToPb(r.StrMap[k])
				}
			}
		} else {
			r.StrMap = make(map[string]*TestStringMap)
		}
		for k := range x.strMap.Dirtied() {
			if !slices.Contains(updated, k) {
				tmp := x.strMap.Get(k)
				if r.StrMap[k] == nil {
					r.StrMap[k] = &TestStringMap{}
				}
				tmp.MergeDirtyToPb(r.StrMap[k])
			}
		}
		if r.StrMapDeleted == nil && len(x.strMap.Deleted()) > 0 {
			r.StrMapDeleted = make([]string, 0)
		}
		for k := range x.strMap.Deleted() {
			if !slices.Contains(r.StrMapDeleted, k) {
				r.StrMapDeleted = append(r.StrMapDeleted, k)
			}
		}
	}
	if x.isF32Dirty() {
		r.SetF32(x.f32)
	}
	if x.isF64Dirty() {
		r.SetF64(x.f64)
	}
	if x.isF32ArrDirty() {
		count := x.f32Arr.Len()
		r.F32Arr = make([]float32, 0)
		if count > 0 {
			r.F32ArrCleared = false
			r.F32Arr = append(r.F32Arr, x.f32Arr.ValueView()...)
		} else {
			r.F32ArrCleared = true
		}
	}
	if x.isF64ArrDirty() {
		count := x.f64Arr.Len()
		r.F64Arr = make([]float64, 0)
		if count > 0 {
			r.F64ArrCleared = false
			r.F64Arr = append(r.F64Arr, x.f64Arr.ValueView()...)
		} else {
			r.F64ArrCleared = true
		}
	}
}
func (x *TestSync) SetDirty(index int, dirty bool, sync syncdep.Sync) {
	idx := index >> 3
	off := index & 7
	if dirty {
		x.dirtyFieldMark[idx] = x.dirtyFieldMark[idx] | (1 << off)
		x.SetParentDirty()
	} else {
		x.dirtyFieldMark[idx] = x.dirtyFieldMark[idx] & ^(1 << off)
	}
}
func (x *TestSync) SetParentDirty() {
	if x.parent != nil {
		x.parent.SetDirty(x.indexInParent, true, x)
	}
}
func (x *TestSync) SetParent(sync syncdep.Sync, idx int) {
	x.parent = sync
	x.indexInParent = idx
}
func (x *TestSync) FlushDirty(dirty bool) {
	if dirty || x.isIdDirty() {
		x.setIdDirty(dirty, true)
	}
	if dirty || x.isU32Dirty() {
		x.setU32Dirty(dirty, true)
	}
	if dirty || x.isI64Dirty() {
		x.setI64Dirty(dirty, true)
	}
	if dirty || x.isU64Dirty() {
		x.setU64Dirty(dirty, true)
	}
	if dirty || x.isBDirty() {
		x.setBDirty(dirty, true)
	}
	if dirty || x.isEDirty() {
		x.setEDirty(dirty, true)
	}
	if dirty || x.isStrDirty() {
		x.setStrDirty(dirty, true)
	}
	if dirty || x.isObjDirty() {
		x.setObjDirty(dirty, true)
	}
	if dirty || x.isI32ArrDirty() {
		x.setI32ArrDirty(dirty, true)
	}
	if dirty || x.isU32ArrDirty() {
		x.setU32ArrDirty(dirty, true)
	}
	if dirty || x.isI64ArrDirty() {
		x.setI64ArrDirty(dirty, true)
	}
	if dirty || x.isU64ArrDirty() {
		x.setU64ArrDirty(dirty, true)
	}
	if dirty || x.isBoolArrDirty() {
		x.setBoolArrDirty(dirty, true)
	}
	if dirty || x.isEnumArrDirty() {
		x.setEnumArrDirty(dirty, true)
	}
	if dirty || x.isStrArrDirty() {
		x.setStrArrDirty(dirty, true)
	}
	if dirty || x.isI32MapDirty() {
		x.setI32MapDirty(dirty, true)
	}
	if dirty || x.isU32MapDirty() {
		x.setU32MapDirty(dirty, true)
	}
	if dirty || x.isI64MapDirty() {
		x.setI64MapDirty(dirty, true)
	}
	if dirty || x.isU64MapDirty() {
		x.setU64MapDirty(dirty, true)
	}
	if dirty || x.isBoolMapDirty() {
		x.setBoolMapDirty(dirty, true)
	}
	if dirty || x.isStrMapDirty() {
		x.setStrMapDirty(dirty, true)
	}
	if dirty || x.isF32Dirty() {
		x.setF32Dirty(dirty, true)
	}
	if dirty || x.isF64Dirty() {
		x.setF64Dirty(dirty, true)
	}
	if dirty || x.isF32ArrDirty() {
		x.setF32ArrDirty(dirty, true)
	}
	if dirty || x.isF64ArrDirty() {
		x.setF64ArrDirty(dirty, true)
	}
}
func (x *TestSync) setIdDirty(dirty bool, recur bool) {
	x.SetDirty(x.idINDEX, dirty, x)
}
func (x *TestSync) isIdDirty() bool {
	idx := x.idINDEX >> 3
	off := x.idINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setU32Dirty(dirty bool, recur bool) {
	x.SetDirty(x.u32INDEX, dirty, x)
}
func (x *TestSync) isU32Dirty() bool {
	idx := x.u32INDEX >> 3
	off := x.u32INDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setI64Dirty(dirty bool, recur bool) {
	x.SetDirty(x.i64INDEX, dirty, x)
}
func (x *TestSync) isI64Dirty() bool {
	idx := x.i64INDEX >> 3
	off := x.i64INDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setU64Dirty(dirty bool, recur bool) {
	x.SetDirty(x.u64INDEX, dirty, x)
}
func (x *TestSync) isU64Dirty() bool {
	idx := x.u64INDEX >> 3
	off := x.u64INDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setBDirty(dirty bool, recur bool) {
	x.SetDirty(x.bINDEX, dirty, x)
}
func (x *TestSync) isBDirty() bool {
	idx := x.bINDEX >> 3
	off := x.bINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setEDirty(dirty bool, recur bool) {
	x.SetDirty(x.eINDEX, dirty, x)
}
func (x *TestSync) isEDirty() bool {
	idx := x.eINDEX >> 3
	off := x.eINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setStrDirty(dirty bool, recur bool) {
	x.SetDirty(x.strINDEX, dirty, x)
}
func (x *TestSync) isStrDirty() bool {
	idx := x.strINDEX >> 3
	off := x.strINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setObjDirty(dirty bool, recur bool) {
	x.SetDirty(x.objINDEX, dirty, x)
	if recur && x.obj != nil {
		x.obj.FlushDirty(dirty)
	}
}
func (x *TestSync) isObjDirty() bool {
	idx := x.objINDEX >> 3
	off := x.objINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setI32ArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.i32ArrINDEX, dirty, x)
}
func (x *TestSync) isI32ArrDirty() bool {
	idx := x.i32ArrINDEX >> 3
	off := x.i32ArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setU32ArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.u32ArrINDEX, dirty, x)
}
func (x *TestSync) isU32ArrDirty() bool {
	idx := x.u32ArrINDEX >> 3
	off := x.u32ArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setI64ArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.i64ArrINDEX, dirty, x)
}
func (x *TestSync) isI64ArrDirty() bool {
	idx := x.i64ArrINDEX >> 3
	off := x.i64ArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setU64ArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.u64ArrINDEX, dirty, x)
}
func (x *TestSync) isU64ArrDirty() bool {
	idx := x.u64ArrINDEX >> 3
	off := x.u64ArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setBoolArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.boolArrINDEX, dirty, x)
}
func (x *TestSync) isBoolArrDirty() bool {
	idx := x.boolArrINDEX >> 3
	off := x.boolArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setEnumArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.enumArrINDEX, dirty, x)
}
func (x *TestSync) isEnumArrDirty() bool {
	idx := x.enumArrINDEX >> 3
	off := x.enumArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setStrArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.strArrINDEX, dirty, x)
}
func (x *TestSync) isStrArrDirty() bool {
	idx := x.strArrINDEX >> 3
	off := x.strArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setI32MapDirty(dirty bool, recur bool) {
	x.SetDirty(x.i32MapINDEX, dirty, x)
	if recur && x.i32Map != nil {
		x.i32Map.FlushDirty(dirty)
	}
}
func (x *TestSync) isI32MapDirty() bool {
	idx := x.i32MapINDEX >> 3
	off := x.i32MapINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setU32MapDirty(dirty bool, recur bool) {
	x.SetDirty(x.u32MapINDEX, dirty, x)
	if recur && x.u32Map != nil {
		x.u32Map.FlushDirty(dirty)
	}
}
func (x *TestSync) isU32MapDirty() bool {
	idx := x.u32MapINDEX >> 3
	off := x.u32MapINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setI64MapDirty(dirty bool, recur bool) {
	x.SetDirty(x.i64MapINDEX, dirty, x)
	if recur && x.i64Map != nil {
		x.i64Map.FlushDirty(dirty)
	}
}
func (x *TestSync) isI64MapDirty() bool {
	idx := x.i64MapINDEX >> 3
	off := x.i64MapINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setU64MapDirty(dirty bool, recur bool) {
	x.SetDirty(x.u64MapINDEX, dirty, x)
	if recur && x.u64Map != nil {
		x.u64Map.FlushDirty(dirty)
	}
}
func (x *TestSync) isU64MapDirty() bool {
	idx := x.u64MapINDEX >> 3
	off := x.u64MapINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setBoolMapDirty(dirty bool, recur bool) {
	x.SetDirty(x.boolMapINDEX, dirty, x)
	if recur && x.boolMap != nil {
		x.boolMap.FlushDirty(dirty)
	}
}
func (x *TestSync) isBoolMapDirty() bool {
	idx := x.boolMapINDEX >> 3
	off := x.boolMapINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setStrMapDirty(dirty bool, recur bool) {
	x.SetDirty(x.strMapINDEX, dirty, x)
	if recur && x.strMap != nil {
		x.strMap.FlushDirty(dirty)
	}
}
func (x *TestSync) isStrMapDirty() bool {
	idx := x.strMapINDEX >> 3
	off := x.strMapINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setF32Dirty(dirty bool, recur bool) {
	x.SetDirty(x.f32INDEX, dirty, x)
}
func (x *TestSync) isF32Dirty() bool {
	idx := x.f32INDEX >> 3
	off := x.f32INDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setF64Dirty(dirty bool, recur bool) {
	x.SetDirty(x.f64INDEX, dirty, x)
}
func (x *TestSync) isF64Dirty() bool {
	idx := x.f64INDEX >> 3
	off := x.f64INDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setF32ArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.f32ArrINDEX, dirty, x)
}
func (x *TestSync) isF32ArrDirty() bool {
	idx := x.f32ArrINDEX >> 3
	off := x.f32ArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) setF64ArrDirty(dirty bool, recur bool) {
	x.SetDirty(x.f64ArrINDEX, dirty, x)
}
func (x *TestSync) isF64ArrDirty() bool {
	idx := x.f64ArrINDEX >> 3
	off := x.f64ArrINDEX & 7
	return (x.dirtyFieldMark[idx] & (1 << off)) != 0
}
func (x *TestSync) Key() interface{} {
	return x.id
}
func (x *TestSync) SetKey(v interface{}) {
	if x.parent != nil {
		if _, ok := x.parent.(*syncdep.MapSync[int32, *TestSync]); ok {
			panic("TestSync key can not set")
		}
	}
	x.id = v.(int32)
}
func (x *TestSync) GetId() int32 {
	return x.id
}
func (x *TestSync) SetId(v int32) *TestSync {
	if x.id == v {
		return x
	}
	x.id = v
	x.setIdDirty(true, false)
	return x
}
func (x *TestSync) GetU32() uint32 {
	return x.u32
}
func (x *TestSync) SetU32(v uint32) *TestSync {
	if x.u32 == v {
		return x
	}
	x.u32 = v
	x.setU32Dirty(true, false)
	return x
}
func (x *TestSync) GetI64() int64 {
	return x.i64
}
func (x *TestSync) SetI64(v int64) *TestSync {
	if x.i64 == v {
		return x
	}
	x.i64 = v
	x.setI64Dirty(true, false)
	return x
}
func (x *TestSync) GetU64() uint64 {
	return x.u64
}
func (x *TestSync) SetU64(v uint64) *TestSync {
	if x.u64 == v {
		return x
	}
	x.u64 = v
	x.setU64Dirty(true, false)
	return x
}
func (x *TestSync) GetB() bool {
	return x.b
}
func (x *TestSync) SetB(v bool) *TestSync {
	if x.b == v {
		return x
	}
	x.b = v
	x.setBDirty(true, false)
	return x
}
func (x *TestSync) GetE() ColorType {
	return x.e
}
func (x *TestSync) SetE(v ColorType) *TestSync {
	if x.e == v {
		return x
	}
	x.e = v
	x.setEDirty(true, false)
	return x
}
func (x *TestSync) GetStr() string {
	return x.str
}
func (x *TestSync) SetStr(v string) *TestSync {
	if x.str == v {
		return x
	}
	x.str = v
	x.setStrDirty(true, false)
	return x
}
func (x *TestSync) GetObj() *PersonSync {
	if x.obj == nil {
		x.obj = NewPersonSync()
		x.obj.SetParent(x, x.objINDEX)
	}
	return x.obj
}
func (x *TestSync) SetObj(v *PersonSync) *TestSync {
	if v != nil {
		v.SetParent(x, x.objINDEX)
	}
	if x.obj != nil {
		x.obj.SetParent(nil, -1)
	}
	x.obj = v
	x.setObjDirty(true, false)
	return x
}
func (x *TestSync) GetI32Arr() *syncdep.ArraySync[int32] {
	if x.i32Arr == nil {
		x.i32Arr = syncdep.NewArraySync[int32]()
		x.i32Arr.SetParent(x, x.i32ArrINDEX)
	}
	return x.i32Arr
}
func (x *TestSync) GetU32Arr() *syncdep.ArraySync[uint32] {
	if x.u32Arr == nil {
		x.u32Arr = syncdep.NewArraySync[uint32]()
		x.u32Arr.SetParent(x, x.u32ArrINDEX)
	}
	return x.u32Arr
}
func (x *TestSync) GetI64Arr() *syncdep.ArraySync[int64] {
	if x.i64Arr == nil {
		x.i64Arr = syncdep.NewArraySync[int64]()
		x.i64Arr.SetParent(x, x.i64ArrINDEX)
	}
	return x.i64Arr
}
func (x *TestSync) GetU64Arr() *syncdep.ArraySync[uint64] {
	if x.u64Arr == nil {
		x.u64Arr = syncdep.NewArraySync[uint64]()
		x.u64Arr.SetParent(x, x.u64ArrINDEX)
	}
	return x.u64Arr
}
func (x *TestSync) GetBoolArr() *syncdep.ArraySync[bool] {
	if x.boolArr == nil {
		x.boolArr = syncdep.NewArraySync[bool]()
		x.boolArr.SetParent(x, x.boolArrINDEX)
	}
	return x.boolArr
}
func (x *TestSync) GetEnumArr() *syncdep.ArraySync[ColorType] {
	if x.enumArr == nil {
		x.enumArr = syncdep.NewArraySync[ColorType]()
		x.enumArr.SetParent(x, x.enumArrINDEX)
	}
	return x.enumArr
}
func (x *TestSync) GetStrArr() *syncdep.ArraySync[string] {
	if x.strArr == nil {
		x.strArr = syncdep.NewArraySync[string]()
		x.strArr.SetParent(x, x.strArrINDEX)
	}
	return x.strArr
}
func (x *TestSync) GetI32Map() *syncdep.MapSync[int32, *TestI32MapSync] {
	if x.i32Map == nil {
		x.i32Map = syncdep.NewMapSync[int32, *TestI32MapSync]()
		x.i32Map.SetParent(x, x.i32MapINDEX)
	}
	return x.i32Map
}
func (x *TestSync) GetU32Map() *syncdep.MapSync[uint32, *TestU32MapSync] {
	if x.u32Map == nil {
		x.u32Map = syncdep.NewMapSync[uint32, *TestU32MapSync]()
		x.u32Map.SetParent(x, x.u32MapINDEX)
	}
	return x.u32Map
}
func (x *TestSync) GetI64Map() *syncdep.MapSync[int64, *TestI64MapSync] {
	if x.i64Map == nil {
		x.i64Map = syncdep.NewMapSync[int64, *TestI64MapSync]()
		x.i64Map.SetParent(x, x.i64MapINDEX)
	}
	return x.i64Map
}
func (x *TestSync) GetU64Map() *syncdep.MapSync[uint64, *TestU64MapSync] {
	if x.u64Map == nil {
		x.u64Map = syncdep.NewMapSync[uint64, *TestU64MapSync]()
		x.u64Map.SetParent(x, x.u64MapINDEX)
	}
	return x.u64Map
}
func (x *TestSync) GetBoolMap() *syncdep.MapSync[bool, *TestBoolMapSync] {
	if x.boolMap == nil {
		x.boolMap = syncdep.NewMapSync[bool, *TestBoolMapSync]()
		x.boolMap.SetParent(x, x.boolMapINDEX)
	}
	return x.boolMap
}
func (x *TestSync) GetStrMap() *syncdep.MapSync[string, *TestStringMapSync] {
	if x.strMap == nil {
		x.strMap = syncdep.NewMapSync[string, *TestStringMapSync]()
		x.strMap.SetParent(x, x.strMapINDEX)
	}
	return x.strMap
}
func (x *TestSync) GetF32() float32 {
	return x.f32
}
func (x *TestSync) SetF32(v float32) *TestSync {
	if x.f32 == v {
		return x
	}
	x.f32 = v
	x.setF32Dirty(true, false)
	return x
}
func (x *TestSync) GetF64() float64 {
	return x.f64
}
func (x *TestSync) SetF64(v float64) *TestSync {
	if x.f64 == v {
		return x
	}
	x.f64 = v
	x.setF64Dirty(true, false)
	return x
}
func (x *TestSync) GetF32Arr() *syncdep.ArraySync[float32] {
	if x.f32Arr == nil {
		x.f32Arr = syncdep.NewArraySync[float32]()
		x.f32Arr.SetParent(x, x.f32ArrINDEX)
	}
	return x.f32Arr
}
func (x *TestSync) GetF64Arr() *syncdep.ArraySync[float64] {
	if x.f64Arr == nil {
		x.f64Arr = syncdep.NewArraySync[float64]()
		x.f64Arr.SetParent(x, x.f64ArrINDEX)
	}
	return x.f64Arr
}
func (xs *Test) SetId(v int32) {
	xs.Id = &v
}
func (xs *Test) SetU32(v uint32) {
	xs.U32 = &v
}
func (xs *Test) SetI64(v int64) {
	xs.I64 = &v
}
func (xs *Test) SetU64(v uint64) {
	xs.U64 = &v
}
func (xs *Test) SetB(v bool) {
	xs.B = &v
}
func (xs *Test) SetE(v ColorType) {
	xs.E = &v
}
func (xs *Test) SetStr(v string) {
	xs.Str = &v
}
func (xs *Test) SetObj(v *Person) {
	xs.Obj = v
}
func (xs *Test) SetI32Arr(v []int32) {
	xs.I32Arr = v
}
func (xs *Test) SetU32Arr(v []uint32) {
	xs.U32Arr = v
}
func (xs *Test) SetI64Arr(v []int64) {
	xs.I64Arr = v
}
func (xs *Test) SetU64Arr(v []uint64) {
	xs.U64Arr = v
}
func (xs *Test) SetBoolArr(v []bool) {
	xs.BoolArr = v
}
func (xs *Test) SetEnumArr(v []ColorType) {
	xs.EnumArr = v
}
func (xs *Test) SetStrArr(v []string) {
	xs.StrArr = v
}
func (xs *Test) SetI32Map(v map[int32]*TestI32Map) {
	xs.I32Map = v
}
func (xs *Test) SetU32Map(v map[uint32]*TestU32Map) {
	xs.U32Map = v
}
func (xs *Test) SetI64Map(v map[int64]*TestI64Map) {
	xs.I64Map = v
}
func (xs *Test) SetU64Map(v map[uint64]*TestU64Map) {
	xs.U64Map = v
}
func (xs *Test) SetBoolMap(v map[bool]*TestBoolMap) {
	xs.BoolMap = v
}
func (xs *Test) SetStrMap(v map[string]*TestStringMap) {
	xs.StrMap = v
}
func (xs *Test) SetF32(v float32) {
	xs.F32 = &v
}
func (xs *Test) SetF64(v float64) {
	xs.F64 = &v
}
func (xs *Test) SetF32Arr(v []float32) {
	xs.F32Arr = v
}
func (xs *Test) SetF64Arr(v []float64) {
	xs.F64Arr = v
}
