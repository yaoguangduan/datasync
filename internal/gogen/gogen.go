package gogen

import (
	"embed"
	"fmt"
	"github.com/yaoguangduan/datasync/internal/gen"
	"google.golang.org/protobuf/compiler/protogen"
	"os/exec"
	"path/filepath"
)

const (
	dirtyFieldName = "dirtyFieldMark"
	parentSyncName = "parent"
	indexInParName = "indexInParent"
)

//go:embed syncgo.tmpl
var syncTmpl embed.FS

func GenerateGo(sfd gen.SyncDef) {
	protocGen(sfd)
	generateGos(sfd)
}

// GenerateGoFromPlugin plugin的方式生成，每个sfd输出到一个文件
func GenerateGoFromPlugin(plugin *protogen.Plugin, sfd gen.SyncDef) {
	filename := sfd.PluginFile.GeneratedFilenamePrefix + ".syncx.go"
	g := plugin.NewGeneratedFile(filename, sfd.PluginFile.GoImportPath)
	g.P("package ", sfd.PluginFile.GoPackageName)
	fw := gen.NewFileWriter()
	fw.PL()
	fw.PL("//this file is generated by gsync, do not modify it manually !!!")
	fw.PL()
	fw.PL("import \"github.com/yaoguangduan/datasync/syncdep\"")
	fw.PLF("import \"google.golang.org/protobuf/encoding/protowire\"")

	imports := map[string]struct{}{}
	for _, msg := range sfd.Messages {
		for _, field := range msg.MsgFields {
			if field.IsList() && (field.ListType == "float" || field.ListType == "double") {
				imports["math"] = struct{}{}
				break
			}
		}
		for _, field := range msg.MsgFields {
			if field.IsMap() {
				imports["slices"] = struct{}{}
				break
			}
		}
	}
	for s := range imports {
		fw.PLF("import \"%s\"", s)

	}
	fw.PL()
	for _, msg := range sfd.Messages {
		if msg.IsEnum {
			continue
		}
		generateGoStruct(fw, msg, sfd)
		generateStructConstructor(fw, sfd, msg)
		generateManageFunc(fw, sfd, msg)
		generateFieldOperateFunc(fw, sfd, msg)
		generateProtoSyncOperateFunc(fw, sfd, msg)
	}
	g.P(fw.String())
}

func generateGos(sfd gen.SyncDef) {
	outputPath := sfd.Defs["go_out"]
	for _, msg := range sfd.Messages {
		if msg.IsEnum {
			continue
		}
		generateGoFile(outputPath, sfd, msg)
	}
}

func goFieldIndexName(name string) string {
	return name + "INDEX"
}

func generateGoFile(path string, sfd gen.SyncDef, msg gen.SyncMsgOrEnumDef) {
	fw := gen.NewFileWriter()
	fw.PL("package ", filepath.Base(path))
	fw.PL()
	fw.PL("//this file is generated by gsync, do not modify it manually !!!")
	fw.PL()
	fw.PL("import \"github.com/yaoguangduan/datasync/syncdep\"")
	fw.PLF("import \"google.golang.org/protobuf/encoding/protowire\"")
	for _, field := range msg.MsgFields {
		if field.IsList() && (field.ListType == "float" || field.ListType == "double") {
			fw.PL("import \"math\"")
			break
		}
	}
	for _, field := range msg.MsgFields {
		if field.IsMap() {
			fw.PL("import \"slices\"")
			break
		}
	}
	fw.PL()
	generateGoStruct(fw, msg, sfd)
	generateStructConstructor(fw, sfd, msg)
	generateManageFunc(fw, sfd, msg)
	generateFieldOperateFunc(fw, sfd, msg)
	generateProtoSyncOperateFunc(fw, sfd, msg)

	fw.Save(filepath.Join(path, msg.Name+".sync.go"))
}

func generateGoStruct(fw *gen.FileWriter, msg gen.SyncMsgOrEnumDef, sfd gen.SyncDef) {
	fw.PLF("type %s struct {", msg.SyncName)
	for _, field := range msg.MsgFields {
		fw.PLF("%s %s", field.Name, field.GoName())
		fw.PLF("%s int", goFieldIndexName(field.Name))
	}
	fw.PLF("%s []uint8", dirtyFieldName)
	fw.PLF("%s syncdep.Sync", parentSyncName)
	fw.PLF("%s int", indexInParName)
	fw.PL("}")
}

func generateManageFunc(fw *gen.FileWriter, sfd gen.SyncDef, msg gen.SyncMsgOrEnumDef) {
	generateFuncClear(fw, msg)
	generateFuncCopyToPb(fw, msg)
	generateFuncCopyFromPb(fw, msg)
	generateFuncMergeDirtyFromPb(fw, msg)
	generateFuncMergeDirtyFromBytes(fw, msg)
	generateFuncMergeDirtyToBytes(fw, msg)
	generateFuncMergeDirtyToPb(fw, msg)
	generateFuncInterfaces(fw, msg)
}

func fieldDefaultVal(field gen.SyncFieldDef) interface{} {
	switch field.Kind {
	case "int32", "int64", "uint32", "uint64", "float", "double":
		return 0
	case "string":
		return "\"\""
	case "bool":
		return false
	case "bytes":
		return "make([]byte,0)"
	case "enum":
		return field.MsgOrEnumRef.Name + "_" + field.MsgOrEnumRef.EnumValues[0].Value
	}
	panic(fmt.Sprintf("invalid kind:%s", field.Kind))
}

func generateStructConstructor(fw *gen.FileWriter, sfd gen.SyncDef, msg gen.SyncMsgOrEnumDef) {
	fw.PLF("func New%s() *%s {", msg.SyncName, msg.SyncName)

	fw.PLF("return &%s{", msg.SyncName)
	for i, field := range msg.MsgFields {
		fw.PLF("%s: %d,", goFieldIndexName(field.Name), i)
	}
	fw.PLF("%s: %s,", dirtyFieldName, fmt.Sprintf("make([]uint8,%d)", len(msg.MsgFields)/8+1))
	fw.PL("}")

	fw.PL("}")
}

func protocGen(sdf gen.SyncDef) {
	cmd := exec.Command("./protoc.exe", "--go_out="+sdf.Defs["go_out"], "--proto_path="+sdf.Defs["proto_out"], sdf.Defs["proto_out"]+"/*proto")
	fmt.Println(cmd.String())
	out, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Println(string(out))
		panic(err)
	}
	fmt.Println("Protobuf file compiled successfully.")
}
